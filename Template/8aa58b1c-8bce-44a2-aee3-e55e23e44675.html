<meta http-equiv="Content-Type" content="text/html; charset=utf-8"><p>left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录 <br />
right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录<br />
inner join(等值连接) 只返回两个表中联结字段相等的行<br />
<br />
举例如下： <br />
--------------------------------------------<br />
表A记录如下：<br />
aID　　　　　aNum<br />
1　　　　　a20050111<br />
2　　　　　a20050112<br />
3　　　　　a20050113<br />
4　　　　　a20050114<br />
5　　　　　a20050115<br />
<br />
表B记录如下:<br />
bID　　　　　bName<br />
1　　　　　2006032401<br />
2　　　　　2006032402<br />
3　　　　　2006032403<br />
4　　　　　2006032404<br />
8　　　　　2006032408<br />
<br />
--------------------------------------------<br />
1.left join<br />
sql语句如下: <br />
select * from A<br />
left join B <br />
on A.aID = B.bID<br />
<br />
结果如下:<br />
aID　　　　　aNum　　　　　bID　　　　　bName<br />
1　　　　　a20050111　　　　1　　　　　2006032401<br />
2　　　　　a20050112　　　　2　　　　　2006032402<br />
3　　　　　a20050113　　　　3　　　　　2006032403<br />
4　　　　　a20050114　　　　4　　　　　2006032404<br />
5　　　　　a20050115　　　　NULL　　　　　NULL<br />
<br />
（所影响的行数为 5 行）<br />
结果说明:<br />
left join是以A表的记录为基础的,A可以看成左表,B可以看成右表,left join是以左表为准的.<br />
换句话说,左表(A)的记录将会全部表示出来,而右表(B)只会显示符合搜索条件的记录(例子中为: A.aID = B.bID).<br />
B表记录不足的地方均为NULL.<br />
--------------------------------------------<br />
2.right join<br />
sql语句如下: <br />
select * from A<br />
right join B <br />
on A.aID = B.bID<br />
<br />
结果如下:<br />
aID　　　　　aNum　　　　　bID　　　　　bName<br />
1　　　　　a20050111　　　　1　　　　　2006032401<br />
2　　　　　a20050112　　　　2　　　　　2006032402<br />
3　　　　　a20050113　　　　3　　　　　2006032403<br />
4　　　　　a20050114　　　　4　　　　　2006032404<br />
NULL　　　　　NULL　　　　　8　　　　　2006032408<br />
<br />
（所影响的行数为 5 行）<br />
结果说明:<br />
仔细观察一下,就会发现,和left join的结果刚好相反,这次是以右表(B)为基础的,A表不足的地方用NULL填充.<br />
--------------------------------------------<br />
3.inner join<br />
sql语句如下: <br />
select * from A<br />
innerjoin B <br />
on A.aID = B.bID<br />
<br />
结果如下:<br />
aID　　　　　aNum　　　　　bID　　　　　bName<br />
1　　　　　a20050111　　　　1　　　　　2006032401<br />
2　　　　　a20050112　　　　2　　　　　2006032402<br />
3　　　　　a20050113　　　　3　　　　　2006032403<br />
4　　　　　a20050114　　　　4　　　　　2006032404<br />
<br />
结果说明:<br />
很明显,这里只显示出了 A.aID = B.bID的记录.这说明inner join并不以谁为基础,它只显示符合条件的记录.<br />
--------------------------------------------<br />
注: <br />
LEFT JOIN操作用于在任何的 FROM 子句中，组合来源表的记录。使用 LEFT JOIN 运算来创建一个左边外部联接。左边外部联接将包含了从第一个（左边）开始的两个表中的全部记录，即使在第二个（右边）表中并没有相符值的记录。<br />
<br />
语法：FROM table1 LEFT JOIN table2 ON table1.field1 compopr table2.field2<br />
<br />
说明：table1, table2参数用于指定要将记录组合的表的名称。<br />
field1, field2参数指定被联接的字段的名称。且这些字段必须有相同的数据类型及包含相同类型的数据，但它们不需要有相同的名称。<br />
compopr参数指定关系比较运算符："="， "<"， ">"， "<="， ">=" 或 "<>"。<br />
如果在INNER JOIN操作中要联接包含Memo 数据类型或 OLE Object 数据类型数据的字段，将会发生错误.<br />
</p> 
uploaded by Patrick. 06/27/2016 14:36:49
